(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ngx-logger'), require('@angular/core'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ngx-logger/testing', ['exports', 'ngx-logger', '@angular/core', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-logger'] = global['ngx-logger'] || {}, global['ngx-logger'].testing = {}), global['ngx-logger'], global.ng.core, global.rxjs));
}(this, (function (exports, ngxLogger, core, rxjs) { 'use strict';

    var NGXLoggerMock = /** @class */ (function () {
        function NGXLoggerMock() {
        }
        NGXLoggerMock.prototype.trace = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.debug = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.info = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.log = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.warn = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.error = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.fatal = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.updateConfig = function (config) {
        };
        NGXLoggerMock.prototype.setCustomHttpHeaders = function (headers) {
        };
        NGXLoggerMock.prototype.setCustomParams = function (params) {
        };
        NGXLoggerMock.prototype.registerMonitor = function (monitor) {
        };
        NGXLoggerMock.prototype.setWithCredentialsOptionValue = function (withCredentials) {
        };
        NGXLoggerMock.prototype.getConfigSnapshot = function () {
            return new ngxLogger.LoggerConfig();
        };
        return NGXLoggerMock;
    }());
    NGXLoggerMock.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NGXLoggerMock.ctorParameters = function () { return []; };

    /**
     * CustomNGXLoggerServiceMock is a mock for CustomNGXLoggerService
     */
    var CustomNGXLoggerServiceMock = /** @class */ (function () {
        function CustomNGXLoggerServiceMock() {
        }
        CustomNGXLoggerServiceMock.prototype.create = function () {
            // you can inject your own httpService or use the default,
            return new NGXLoggerMock();
        };
        return CustomNGXLoggerServiceMock;
    }());
    CustomNGXLoggerServiceMock.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    CustomNGXLoggerServiceMock.ctorParameters = function () { return []; };

    var NGXLoggerHttpServiceMock = /** @class */ (function () {
        function NGXLoggerHttpServiceMock() {
        }
        NGXLoggerHttpServiceMock.prototype.logOnServer = function (url, message, additional, timestamp, logLevel) {
            return rxjs.of({});
        };
        return NGXLoggerHttpServiceMock;
    }());
    NGXLoggerHttpServiceMock.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NGXLoggerHttpServiceMock.ctorParameters = function () { return []; };

    var NGXMapperServiceMock = /** @class */ (function () {
        function NGXMapperServiceMock() {
        }
        NGXMapperServiceMock.prototype.getCallerDetails = function () {
            return rxjs.of({ fileName: 'test.ts', lineNumber: 0, columnNumber: 0 });
        };
        return NGXMapperServiceMock;
    }());
    NGXMapperServiceMock.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NGXMapperServiceMock.ctorParameters = function () { return []; };

    var LoggerTestingModule = /** @class */ (function () {
        function LoggerTestingModule() {
        }
        return LoggerTestingModule;
    }());
    LoggerTestingModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [ngxLogger.LoggerModule],
                    providers: [
                        { provide: ngxLogger.NGXLogger, useClass: NGXLoggerMock },
                        { provide: ngxLogger.NGXLoggerHttpService, useClass: NGXLoggerHttpServiceMock },
                        { provide: ngxLogger.CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
                        { provide: ngxLogger.NGXMapperService, useClass: NGXMapperServiceMock }
                    ]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CustomNGXLoggerServiceMock = CustomNGXLoggerServiceMock;
    exports.LoggerTestingModule = LoggerTestingModule;
    exports.NGXLoggerHttpServiceMock = NGXLoggerHttpServiceMock;
    exports.NGXLoggerMock = NGXLoggerMock;
    exports.NGXMapperServiceMock = NGXMapperServiceMock;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-logger-testing.umd.js.map
