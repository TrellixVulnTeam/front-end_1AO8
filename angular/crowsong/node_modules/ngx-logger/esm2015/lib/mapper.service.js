import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
export class NGXMapperService {
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
        // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
        this.sourceMapCache = new Map();
        // cache for specific log position, key is the dist position, ie 'main.js:339:21'
        this.logPositionCache = new Map();
    }
    /*
    Static Functions
   */
    static getStackLine(proxiedSteps) {
        const error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                // Here are different examples of stacktrace 
                // Firefox (last line is the user code, the 4 first are ours):
                // getStackLine@http://localhost:4200/main.js:358:23
                // getCallerDetails@http://localhost:4200/main.js:557:44
                // _log@http://localhost:4200/main.js:830:28
                // debug@http://localhost:4200/main.js:652:14
                // handleLog@http://localhost:4200/main.js:1158:29
                // Chrome and Edge (last line is the user code):
                // Error
                // at Function.getStackLine (ngx-logger.js:329)
                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)
                // at NGXLogger._log (ngx-logger.js:801)
                // at NGXLogger.info (ngx-logger.js:631)
                // at AppComponent.handleLog (app.component.ts:38)
                let defaultProxy = 4; // We make 4 functions call before getting here
                const firstStackLine = error.stack.split('\n')[0];
                if (!firstStackLine.includes('.js:')) {
                    // The stacktrace starts with no function call (example in Chrome or Edge)
                    defaultProxy = defaultProxy + 1;
                }
                return error.stack.split('\n')[(defaultProxy + (proxiedSteps || 0))];
            }
            catch (e) {
                return null;
            }
        }
    }
    static getPosition(stackLine) {
        // strip base path, then parse filename, line, and column
        const positionStartIndex = stackLine.lastIndexOf('\/');
        let positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        const dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    }
    static getTranspileLocation(stackLine) {
        // Example stackLine:
        // Firefox : getStackLine@http://localhost:4200/main.js:358:23
        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)
        let locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf('@');
            if (locationStartIndex < 0) {
                locationStartIndex = stackLine.lastIndexOf(' ');
            }
        }
        let locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    }
    static getMapFilePath(stackLine) {
        const file = NGXMapperService.getTranspileLocation(stackLine);
        const mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    }
    static getMapping(sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        let sourceFileIndex = 0, // second field
        sourceCodeLine = 0, // third field
        sourceCodeColumn = 0; // fourth field
        const lines = sourceMap.mappings.split(';');
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            let generatedCodeColumn = 0;
            // decode sections in line
            const columns = lines[lineIndex].split(',');
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                const decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * does the http get request to get the source map
     * @param sourceMapLocation
     * @param distPosition
     */
    _getSourceMap(sourceMapLocation, distPosition) {
        const req = new HttpRequest('GET', sourceMapLocation);
        const distPositionKey = distPosition.toString();
        // if the specific log position is already in cache return it
        if (this.logPositionCache.has(distPositionKey)) {
            return this.logPositionCache.get(distPositionKey);
        }
        // otherwise check if the source map is already cached for given source map location
        if (!this.sourceMapCache.has(sourceMapLocation)) {
            // obtain the source map if not cached
            this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));
        }
        // at this point the source map is cached, use it to get specific log position mapping
        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => 
        // map generated position to source position
        NGXMapperService.getMapping(sourceMap, distPosition)), catchError(() => of(distPosition)), shareReplay(1));
        // store specific log position in cache for given dest position and return it
        this.logPositionCache.set(distPositionKey, logPosition$);
        return logPosition$;
    }
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param sourceMapsEnabled
     * @param proxiedSteps
     */
    getCallerDetails(sourceMapsEnabled, proxiedSteps) {
        // parse generated file mapping from stack trace
        const stackLine = NGXMapperService.getStackLine(proxiedSteps);
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap(([distPosition, sourceMapLocation]) => {
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return this._getSourceMap(sourceMapLocation, distPosition);
        }));
    }
}
NGXMapperService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXMapperService.ctorParameters = () => [
    { type: HttpBackend }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUUsT0FBTyxLQUFLLEdBQUcsTUFBTSxLQUFLLENBQUM7QUFDM0IsT0FBTyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFHbkQsTUFBTSxPQUFPLGdCQUFnQjtJQVEzQixZQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQU41Qyw2RkFBNkY7UUFDckYsbUJBQWMsR0FBdUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUV2RSxpRkFBaUY7UUFDekUscUJBQWdCLEdBQXlDLElBQUksR0FBRyxFQUFFLENBQUM7SUFHM0UsQ0FBQztJQUVEOztLQUVDO0lBQ08sTUFBTSxDQUFDLFlBQVksQ0FBQyxZQUFvQjtRQUM5QyxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBRTFCLElBQUk7WUFDRix3Q0FBd0M7WUFDeEMsTUFBTSxLQUFLLENBQUM7U0FDYjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBRVYsSUFBSTtnQkFDRiw2Q0FBNkM7Z0JBRTdDLDhEQUE4RDtnQkFDOUQsb0RBQW9EO2dCQUNwRCx3REFBd0Q7Z0JBQ3hELDRDQUE0QztnQkFDNUMsNkNBQTZDO2dCQUM3QyxrREFBa0Q7Z0JBRWxELGdEQUFn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QUMsQ0FBQztTQUN0QztRQUVELE9BQU8sRUFBRSxDQUFDO1lBQ1IsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQztZQUN2QyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDO1NBQzNDLENBQUMsQ0FBQyxJQUFJLENBQ0wsU0FBUyxDQUFpRCxDQUFDLENBQUMsWUFBWSxFQUFFLGlCQUFpQixDQUFDLEVBQUUsRUFBRTtZQUU5Rix3R0FBd0c7WUFDeEcsNkRBQTZEO1lBQzdELElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDekI7WUFFRCw0REFBNEQ7WUFDNUQsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzdELENBQUMsQ0FBQyxDQUNILENBQUM7SUFHSixDQUFDOzs7WUE1TkYsVUFBVTs7OztZQU5GLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb3VyY2VNYXAgfSBmcm9tICdAYW5ndWxhci9jb21waWxlcic7XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSHR0cEJhY2tlbmQsIEh0dHBSZXF1ZXN0LCBIdHRwUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCAqIGFzIHZscSBmcm9tICd2bHEnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yLCBmaWx0ZXIsIG1hcCwgcmV0cnksIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IExvZ1Bvc2l0aW9uIH0gZnJvbSAnLi90eXBlcy9sb2ctcG9zaXRpb24nO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTkdYTWFwcGVyU2VydmljZSB7XHJcblxyXG4gIC8vIGNhY2hlIGZvciBzb3VyY2UgbWFwcywga2V5IGlzIHNvdXJjZSBtYXAgbG9jYXRpb24sIGllLiAnaHR0cDovL2xvY2FsaG9zdDo0MjAwL21haW4uanMubWFwJ1xyXG4gIHByaXZhdGUgc291cmNlTWFwQ2FjaGU6IE1hcDxzdHJpbmcsIE9ic2VydmFibGU8U291cmNlTWFwPj4gPSBuZXcgTWFwKCk7XHJcblxyXG4gIC8vIGNhY2hlIGZvciBzcGVjaWZpYyBsb2cgcG9zaXRpb24sIGtleSBpcyB0aGUgZGlzdCBwb3NpdGlvbiwgaWUgJ21haW4uanM6MzM5OjIxJ1xyXG4gIHByaXZhdGUgbG9nUG9zaXRpb25DYWNoZTogTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4+ID0gbmV3IE1hcCgpO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHBCYWNrZW5kOiBIdHRwQmFja2VuZCkge1xyXG4gIH1cclxuXHJcbiAgLypcclxuICBTdGF0aWMgRnVuY3Rpb25zXHJcbiAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGdldFN0YWNrTGluZShwcm94aWVkU3RlcHM6IG51bWJlcik6IHN0cmluZyB7XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIG5vaW5zcGVjdGlvbiBFeGNlcHRpb25DYXVnaHRMb2NhbGx5SlNcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIEhlcmUgYXJlIGRpZmZlcmVudCBleGFtcGxlcyBvZiBzdGFja3RyYWNlIFxyXG5cclxuICAgICAgICAvLyBGaXJlZm94IChsYXN0IGxpbmUgaXMgdGhlIHVzZXIgY29kZSwgdGhlIDQgZmlyc3QgYXJlIG91cnMpOlxyXG4gICAgICAgIC8vIGdldFN0YWNrTGluZUBodHRwOi8vbG9jYWxob3N0OjQyMDAvbWFpbi5qczozNTg6MjNcclxuICAgICAgICAvLyBnZXRDYWxsZXJEZXRhaWxzQGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMC9tYWluLmpzOjU1Nzo0NFxyXG4gICAgICAgIC8vIF9sb2dAaHR0cDovL2xvY2FsaG9zdDo0MjAwL21haW4uanM6ODMwOjI4XHJcbiAgICAgICAgLy8gZGVidWdAaHR0cDovL2xvY2FsaG9zdDo0MjAwL21haW4uanM6NjUyOjE0XHJcbiAgICAgICAgLy8gaGFuZGxlTG9nQGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMC9tYWluLmpzOjExNTg6MjlcclxuXHJcbiAgICAgICAgLy8gQ2hyb21lIGFuZCBFZGdlIChsYXN0IGxpbmUgaXMgdGhlIHVzZXIgY29kZSk6XHJcbiAgICAgICAgLy8gRXJyb3JcclxuICAgICAgICAvLyBhdCBGdW5jdGlvbi5nZXRTdGFja0xpbmUgKG5neC1sb2dnZXIuanM6MzI5KVxyXG4gICAgICAgIC8vIGF0IE5HWE1hcHBlclNlcnZpY2UuZ2V0Q2FsbGVyRGV0YWlscyAobmd4LWxvZ2dlci5qczo1MjgpXHJcbiAgICAgICAgLy8gYXQgTkdYTG9nZ2VyLl9sb2cgKG5neC1sb2dnZXIuanM6ODAxKVxyXG4gICAgICAgIC8vIGF0IE5HWExvZ2dlci5pbmZvIChuZ3gtbG9nZ2VyLmpzOjYzMSlcclxuICAgICAgICAvLyBhdCBBcHBDb21wb25lbnQuaGFuZGxlTG9nIChhcHAuY29tcG9uZW50LnRzOjM4KVxyXG5cclxuICAgICAgICBsZXQgZGVmYXVsdFByb3h5ID0gNDsgLy8gV2UgbWFrZSA0IGZ1bmN0aW9ucyBjYWxsIGJlZm9yZSBnZXR0aW5nIGhlcmVcclxuICAgICAgICBjb25zdCBmaXJzdFN0YWNrTGluZSA9IGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKVswXTtcclxuICAgICAgICBpZiAoIWZpcnN0U3RhY2tMaW5lLmluY2x1ZGVzKCcuanM6JykpIHtcclxuICAgICAgICAgIC8vIFRoZSBzdGFja3RyYWNlIHN0YXJ0cyB3aXRoIG5vIGZ1bmN0aW9uIGNhbGwgKGV4YW1wbGUgaW4gQ2hyb21lIG9yIEVkZ2UpXHJcbiAgICAgICAgICBkZWZhdWx0UHJveHkgPSBkZWZhdWx0UHJveHkgKyAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKVsoZGVmYXVsdFByb3h5ICsgKHByb3hpZWRTdGVwcyB8fCAwKSldO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGdldFBvc2l0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogTG9nUG9zaXRpb24ge1xyXG4gICAgLy8gc3RyaXAgYmFzZSBwYXRoLCB0aGVuIHBhcnNlIGZpbGVuYW1lLCBsaW5lLCBhbmQgY29sdW1uXHJcbiAgICBjb25zdCBwb3NpdGlvblN0YXJ0SW5kZXggPSBzdGFja0xpbmUubGFzdEluZGV4T2YoJ1xcLycpO1xyXG4gICAgbGV0IHBvc2l0aW9uRW5kSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKScpO1xyXG4gICAgaWYgKHBvc2l0aW9uRW5kSW5kZXggPCAwKSB7XHJcbiAgICAgIHBvc2l0aW9uRW5kSW5kZXggPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcG9zaXRpb24gPSBzdGFja0xpbmUuc3Vic3RyaW5nKHBvc2l0aW9uU3RhcnRJbmRleCArIDEsIHBvc2l0aW9uRW5kSW5kZXgpO1xyXG4gICAgY29uc3QgZGF0YUFycmF5ID0gcG9zaXRpb24uc3BsaXQoJzonKTtcclxuICAgIGlmIChkYXRhQXJyYXkubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oZGF0YUFycmF5WzBdLCArZGF0YUFycmF5WzFdLCArZGF0YUFycmF5WzJdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGdldFRyYW5zcGlsZUxvY2F0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIEV4YW1wbGUgc3RhY2tMaW5lOlxyXG4gICAgLy8gRmlyZWZveCA6IGdldFN0YWNrTGluZUBodHRwOi8vbG9jYWxob3N0OjQyMDAvbWFpbi5qczozNTg6MjNcclxuICAgIC8vIENocm9tZSBhbmQgRWRnZSA6IGF0IEZ1bmN0aW9uLmdldFN0YWNrTGluZSAobmd4LWxvZ2dlci5qczozMjkpXHJcbiAgICBsZXQgbG9jYXRpb25TdGFydEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJygnKTtcclxuICAgIGlmIChsb2NhdGlvblN0YXJ0SW5kZXggPCAwKSB7XHJcbiAgICAgIGxvY2F0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignQCcpO1xyXG4gICAgICBpZiAobG9jYXRpb25TdGFydEluZGV4IDwgMCkge1xyXG4gICAgICAgIGxvY2F0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignICcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGxvY2F0aW9uRW5kSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKScpO1xyXG4gICAgaWYgKGxvY2F0aW9uRW5kSW5kZXggPCAwKSB7XHJcbiAgICAgIGxvY2F0aW9uRW5kSW5kZXggPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0YWNrTGluZS5zdWJzdHJpbmcobG9jYXRpb25TdGFydEluZGV4ICsgMSwgbG9jYXRpb25FbmRJbmRleCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyBnZXRNYXBGaWxlUGF0aChzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBmaWxlID0gTkdYTWFwcGVyU2VydmljZS5nZXRUcmFuc3BpbGVMb2NhdGlvbihzdGFja0xpbmUpO1xyXG4gICAgY29uc3QgbWFwRnVsbFBhdGggPSBmaWxlLnN1YnN0cmluZygwLCBmaWxlLmxhc3RJbmRleE9mKCc6JykpO1xyXG4gICAgcmV0dXJuIG1hcEZ1bGxQYXRoLnN1YnN0cmluZygwLCBtYXBGdWxsUGF0aC5sYXN0SW5kZXhPZignOicpKSArICcubWFwJztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGdldE1hcHBpbmcoc291cmNlTWFwOiBTb3VyY2VNYXAsIHBvc2l0aW9uOiBMb2dQb3NpdGlvbik6IExvZ1Bvc2l0aW9uIHtcclxuICAgIC8vID0+ICc7JyBpbmRpY2F0ZXMgZW5kIG9mIGEgbGluZVxyXG4gICAgLy8gPT4gJywnIHNlcGFyYXRlcyBtYXBwaW5ncyBpbiBhIGxpbmVcclxuICAgIC8vIGRlY29kZWQgbWFwcGluZyA9PiBbIGdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUZpbGVJbmRleCwgc291cmNlQ29kZUxpbmUsIHNvdXJjZUNvZGVDb2x1bW4sIG5hbWVJbmRleCBdXHJcbiAgICBsZXQgc291cmNlRmlsZUluZGV4ID0gMCwgICAvLyBzZWNvbmQgZmllbGRcclxuICAgICAgc291cmNlQ29kZUxpbmUgPSAwLCAgICAvLyB0aGlyZCBmaWVsZFxyXG4gICAgICBzb3VyY2VDb2RlQ29sdW1uID0gMDsgIC8vIGZvdXJ0aCBmaWVsZFxyXG5cclxuICAgIGNvbnN0IGxpbmVzID0gc291cmNlTWFwLm1hcHBpbmdzLnNwbGl0KCc7Jyk7XHJcblxyXG4gICAgZm9yIChsZXQgbGluZUluZGV4ID0gMDsgbGluZUluZGV4IDwgbGluZXMubGVuZ3RoOyBsaW5lSW5kZXgrKykge1xyXG4gICAgICAvLyByZXNldCBjb2x1bW4gcG9zaXRpb24gdG8gMCBhZnRlciBlYWNoIGxpbmVcclxuICAgICAgbGV0IGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xyXG4gICAgICAvLyBkZWNvZGUgc2VjdGlvbnMgaW4gbGluZVxyXG4gICAgICBjb25zdCBjb2x1bW5zID0gbGluZXNbbGluZUluZGV4XS5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgZm9yIChsZXQgY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IGNvbHVtbnMubGVuZ3RoOyBjb2x1bW5JbmRleCsrKSB7XHJcbiAgICAgICAgY29uc3QgZGVjb2RlZFNlY3Rpb24gPSB2bHEuZGVjb2RlKGNvbHVtbnNbY29sdW1uSW5kZXhdKTtcclxuICAgICAgICBpZiAoZGVjb2RlZFNlY3Rpb24ubGVuZ3RoID49IDQpIHtcclxuICAgICAgICAgIC8vIHVwZGF0ZSByZWxhdGl2ZSBwb3NpdGlvbnNcclxuICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gKz0gZGVjb2RlZFNlY3Rpb25bMF07XHJcbiAgICAgICAgICBzb3VyY2VGaWxlSW5kZXggKz0gZGVjb2RlZFNlY3Rpb25bMV07XHJcbiAgICAgICAgICBzb3VyY2VDb2RlTGluZSArPSBkZWNvZGVkU2VjdGlvblsyXTtcclxuICAgICAgICAgIHNvdXJjZUNvZGVDb2x1bW4gKz0gZGVjb2RlZFNlY3Rpb25bM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjaGVjayBpZiBtYXRjaGluZyBtYXBcclxuICAgICAgICBpZiAobGluZUluZGV4ID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XHJcbiAgICAgICAgICBpZiAoZ2VuZXJhdGVkQ29kZUNvbHVtbiA9PT0gcG9zaXRpb24uY29sdW1uTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBhbmQgbGluZSBmb3VuZFxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKHNvdXJjZU1hcC5zb3VyY2VzW3NvdXJjZUZpbGVJbmRleF0sIHNvdXJjZUNvZGVMaW5lLCBzb3VyY2VDb2RlQ29sdW1uKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uSW5kZXggKyAxID09PSBjb2x1bW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBjb2x1bW4gbm90IGZvdW5kLCBidXQgbGluZSBpcyBjb3JyZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oc291cmNlTWFwLnNvdXJjZXNbc291cmNlRmlsZUluZGV4XSwgc291cmNlQ29kZUxpbmUsIDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZmFpbGVkIGlmIHJlYWNoZWRcclxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRvZXMgdGhlIGh0dHAgZ2V0IHJlcXVlc3QgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwXHJcbiAgICogQHBhcmFtIHNvdXJjZU1hcExvY2F0aW9uXHJcbiAgICogQHBhcmFtIGRpc3RQb3NpdGlvblxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbjogc3RyaW5nLCBkaXN0UG9zaXRpb246IExvZ1Bvc2l0aW9uKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xyXG4gICAgY29uc3QgcmVxID0gbmV3IEh0dHBSZXF1ZXN0PFNvdXJjZU1hcD4oJ0dFVCcsIHNvdXJjZU1hcExvY2F0aW9uKTtcclxuICAgIGNvbnN0IGRpc3RQb3NpdGlvbktleSA9IGRpc3RQb3NpdGlvbi50b1N0cmluZygpO1xyXG5cclxuICAgIC8vIGlmIHRoZSBzcGVjaWZpYyBsb2cgcG9zaXRpb24gaXMgYWxyZWFkeSBpbiBjYWNoZSByZXR1cm4gaXRcclxuICAgIGlmICh0aGlzLmxvZ1Bvc2l0aW9uQ2FjaGUuaGFzKGRpc3RQb3NpdGlvbktleSkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubG9nUG9zaXRpb25DYWNoZS5nZXQoZGlzdFBvc2l0aW9uS2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvdGhlcndpc2UgY2hlY2sgaWYgdGhlIHNvdXJjZSBtYXAgaXMgYWxyZWFkeSBjYWNoZWQgZm9yIGdpdmVuIHNvdXJjZSBtYXAgbG9jYXRpb25cclxuICAgIGlmICghdGhpcy5zb3VyY2VNYXBDYWNoZS5oYXMoc291cmNlTWFwTG9jYXRpb24pKSB7XHJcbiAgICAgIC8vIG9idGFpbiB0aGUgc291cmNlIG1hcCBpZiBub3QgY2FjaGVkXHJcbiAgICAgIHRoaXMuc291cmNlTWFwQ2FjaGUuc2V0KFxyXG4gICAgICAgIHNvdXJjZU1hcExvY2F0aW9uLFxyXG4gICAgICAgIHRoaXMuaHR0cEJhY2tlbmQuaGFuZGxlKHJlcSkucGlwZShcclxuICAgICAgICAgIGZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSksXHJcbiAgICAgICAgICBtYXA8SHR0cFJlc3BvbnNlPFNvdXJjZU1hcD4sIFNvdXJjZU1hcD4oXHJcbiAgICAgICAgICAgIChodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZTxTb3VyY2VNYXA+KSA9PiBodHRwUmVzcG9uc2UuYm9keVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIHJldHJ5KDMpLFxyXG4gICAgICAgICAgc2hhcmVSZXBsYXkoMSlcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgc291cmNlIG1hcCBpcyBjYWNoZWQsIHVzZSBpdCB0byBnZXQgc3BlY2lmaWMgbG9nIHBvc2l0aW9uIG1hcHBpbmdcclxuICAgIGNvbnN0IGxvZ1Bvc2l0aW9uJCA9IHRoaXMuc291cmNlTWFwQ2FjaGUuZ2V0KHNvdXJjZU1hcExvY2F0aW9uKS5waXBlKFxyXG4gICAgICBtYXA8U291cmNlTWFwLCBMb2dQb3NpdGlvbj4oKHNvdXJjZU1hcCkgPT5cclxuICAgICAgICAvLyBtYXAgZ2VuZXJhdGVkIHBvc2l0aW9uIHRvIHNvdXJjZSBwb3NpdGlvblxyXG4gICAgICAgIE5HWE1hcHBlclNlcnZpY2UuZ2V0TWFwcGluZyhzb3VyY2VNYXAsIGRpc3RQb3NpdGlvbilcclxuICAgICAgKSxcclxuICAgICAgY2F0Y2hFcnJvcigoKSA9PiBvZihkaXN0UG9zaXRpb24pKSxcclxuICAgICAgc2hhcmVSZXBsYXkoMSlcclxuICAgICk7XHJcblxyXG4gICAgLy8gc3RvcmUgc3BlY2lmaWMgbG9nIHBvc2l0aW9uIGluIGNhY2hlIGZvciBnaXZlbiBkZXN0IHBvc2l0aW9uIGFuZCByZXR1cm4gaXRcclxuICAgIHRoaXMubG9nUG9zaXRpb25DYWNoZS5zZXQoZGlzdFBvc2l0aW9uS2V5LCBsb2dQb3NpdGlvbiQpO1xyXG5cclxuICAgIHJldHVybiBsb2dQb3NpdGlvbiQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBMb2dQb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgbG9nXHJcbiAgICogSWYgc291cmNlTWFwcyBhcmUgZW5hYmxlZCwgaXQgYXR0ZW1wcyB0byBnZXQgdGhlIHNvdXJjZSBtYXAgZnJvbSB0aGUgc2VydmVyLCBhbmQgdXNlIHRoYXQgdG8gcGFyc2UgdGhlIGZpbGUgbmFtZVxyXG4gICAqIGFuZCBudW1iZXIgb2YgdGhlIGNhbGxcclxuICAgKiBAcGFyYW0gc291cmNlTWFwc0VuYWJsZWRcclxuICAgKiBAcGFyYW0gcHJveGllZFN0ZXBzXHJcbiAgICovXHJcbiAgcHVibGljIGdldENhbGxlckRldGFpbHMoc291cmNlTWFwc0VuYWJsZWQ6IGJvb2xlYW4sIHByb3hpZWRTdGVwczogbnVtYmVyKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xyXG4gICAgLy8gcGFyc2UgZ2VuZXJhdGVkIGZpbGUgbWFwcGluZyBmcm9tIHN0YWNrIHRyYWNlXHJcblxyXG4gICAgY29uc3Qgc3RhY2tMaW5lID0gTkdYTWFwcGVyU2VydmljZS5nZXRTdGFja0xpbmUocHJveGllZFN0ZXBzKTtcclxuXHJcbiAgICAvLyBpZiB3ZSB3ZXJlIG5vdCBhYmxlIHRvIHBhcnNlIHRoZSBzdGFja0xpbmUsIGp1c3QgcmV0dXJuIGFuIGVtcHR5IExvZyBQb3NpdGlvblxyXG4gICAgaWYgKCFzdGFja0xpbmUpIHtcclxuICAgICAgcmV0dXJuIG9mKG5ldyBMb2dQb3NpdGlvbignJywgMCwgMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvZihbXHJcbiAgICAgIE5HWE1hcHBlclNlcnZpY2UuZ2V0UG9zaXRpb24oc3RhY2tMaW5lKSxcclxuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRNYXBGaWxlUGF0aChzdGFja0xpbmUpXHJcbiAgICBdKS5waXBlKFxyXG4gICAgICBzd2l0Y2hNYXA8W0xvZ1Bvc2l0aW9uLCBzdHJpbmddLCBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPj4oKFtkaXN0UG9zaXRpb24sIHNvdXJjZU1hcExvY2F0aW9uXSkgPT4ge1xyXG5cclxuICAgICAgICAvLyBpZiBzb3VyY2UgbWFwcyBhcmUgbm90IGVuYWJsZWQsIG9yIGlmIHdlJ3ZlIHByZXZpb3VzbHkgdHJpZWQgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwcywgYnV0IHRoZXkgZmFpbGVkLFxyXG4gICAgICAgIC8vIHRoZW4ganVzdCB1c2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBKUyBpbnN0ZWFkIG9mIHRoZSBzb3VyY2VcclxuICAgICAgICBpZiAoIXNvdXJjZU1hcHNFbmFibGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2YoZGlzdFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmFsbHkgdHJ5IHRvIGdldCB0aGUgc291cmNlIG1hcCBhbmQgcmV0dXJuIHRoZSBwb3NpdGlvblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTb3VyY2VNYXAoc291cmNlTWFwTG9jYXRpb24sIGRpc3RQb3NpdGlvbik7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuXHJcbiAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG4iXX0=