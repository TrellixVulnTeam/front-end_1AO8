(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/common/http'), require('rxjs/operators'), require('vlq'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ngx-logger', ['exports', '@angular/common', '@angular/core', '@angular/common/http', 'rxjs/operators', 'vlq', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-logger'] = {}, global.ng.common, global.ng.core, global.ng.common.http, global.rxjs.operators, global.vlq, global.rxjs));
}(this, (function (exports, common, core, http, operators, vlq, rxjs) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var NGXLoggerHttpService = /** @class */ (function () {
        function NGXLoggerHttpService(httpBackend) {
            this.httpBackend = httpBackend;
        }
        NGXLoggerHttpService.prototype.logOnServer = function (url, log, options) {
            // HttpBackend skips all HttpInterceptors
            // They may log errors using this service causing circular calls
            var req = new http.HttpRequest('POST', url, log, options || {});
            return this.httpBackend.handle(req).pipe(operators.filter(function (e) { return e instanceof http.HttpResponse; }), operators.map(function (httpResponse) { return httpResponse.body; }));
        };
        return NGXLoggerHttpService;
    }());
    NGXLoggerHttpService.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NGXLoggerHttpService.ctorParameters = function () { return [
        { type: http.HttpBackend }
    ]; };

    (function (NgxLoggerLevel) {
        NgxLoggerLevel[NgxLoggerLevel["TRACE"] = 0] = "TRACE";
        NgxLoggerLevel[NgxLoggerLevel["DEBUG"] = 1] = "DEBUG";
        NgxLoggerLevel[NgxLoggerLevel["INFO"] = 2] = "INFO";
        NgxLoggerLevel[NgxLoggerLevel["LOG"] = 3] = "LOG";
        NgxLoggerLevel[NgxLoggerLevel["WARN"] = 4] = "WARN";
        NgxLoggerLevel[NgxLoggerLevel["ERROR"] = 5] = "ERROR";
        NgxLoggerLevel[NgxLoggerLevel["FATAL"] = 6] = "FATAL";
        NgxLoggerLevel[NgxLoggerLevel["OFF"] = 7] = "OFF";
    })(exports.NgxLoggerLevel || (exports.NgxLoggerLevel = {}));

    var LoggerConfig = /** @class */ (function () {
        function LoggerConfig() {
        }
        return LoggerConfig;
    }());

    var NGXLoggerConfigEngine = /** @class */ (function () {
        function NGXLoggerConfigEngine(config) {
            this.config = config;
            this._config = config;
        }
        Object.defineProperty(NGXLoggerConfigEngine.prototype, "level", {
            /** Get a readonly access to the level configured for the NGXLogger */
            get: function () {
                return this._config.level;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NGXLoggerConfigEngine.prototype, "serverLogLevel", {
            /** Get a readonly access to the serverLogLevel configured for the NGXLogger */
            get: function () {
                return this._config.serverLogLevel;
            },
            enumerable: false,
            configurable: true
        });
        NGXLoggerConfigEngine.prototype.updateConfig = function (config) {
            this._config = this._clone(config);
        };
        NGXLoggerConfigEngine.prototype.getConfig = function () {
            return this._clone(this._config);
        };
        // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)
        // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make
        // this a deep clone
        NGXLoggerConfigEngine.prototype._clone = function (object) {
            var cloneConfig = new LoggerConfig();
            Object.keys(object).forEach(function (key) {
                cloneConfig[key] = object[key];
            });
            return cloneConfig;
        };
        return NGXLoggerConfigEngine;
    }());

    var DEFAULT_COLOR_SCHEME = [
        'purple',
        'teal',
        'gray',
        'gray',
        'red',
        'red',
        'red'
    ];

    var NGXLoggerUtils = /** @class */ (function () {
        function NGXLoggerUtils() {
        }
        NGXLoggerUtils.prepareMetaString = function (timestamp, logLevel, fileName, lineNumber) {
            var fileDetails = fileName ? " [" + fileName + ":" + lineNumber + "]" : '';
            return timestamp + " " + logLevel + fileDetails;
        };
        NGXLoggerUtils.getColor = function (level, configColorScheme) {
            switch (level) {
                case exports.NgxLoggerLevel.TRACE:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.TRACE, configColorScheme);
                case exports.NgxLoggerLevel.DEBUG:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.DEBUG, configColorScheme);
                case exports.NgxLoggerLevel.INFO:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.INFO, configColorScheme);
                case exports.NgxLoggerLevel.LOG:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.LOG, configColorScheme);
                case exports.NgxLoggerLevel.WARN:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.WARN, configColorScheme);
                case exports.NgxLoggerLevel.ERROR:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.ERROR, configColorScheme);
                case exports.NgxLoggerLevel.FATAL:
                    return this.getColorFromConfig(exports.NgxLoggerLevel.FATAL, configColorScheme);
                case exports.NgxLoggerLevel.OFF:
                default:
                    return;
            }
        };
        NGXLoggerUtils.getColorFromConfig = function (level, configColorScheme) {
            if (!configColorScheme) {
                return DEFAULT_COLOR_SCHEME[level];
            }
            return configColorScheme[level];
        };
        NGXLoggerUtils.prepareMessage = function (message) {
            try {
                if (typeof message !== 'string' && !(message instanceof Error)) {
                    message = JSON.stringify(message, null, 2);
                }
            }
            catch (e) {
                // additional = [message, ...additional];
                message = 'The provided "message" value could not be parsed with JSON.stringify().';
            }
            return message;
        };
        NGXLoggerUtils.prepareAdditionalParameters = function (additional) {
            if (additional === null || additional === undefined) {
                return null;
            }
            return additional.map(function (next, idx) {
                try {
                    // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                    if (typeof next === 'object') {
                        JSON.stringify(next);
                    }
                    return next;
                }
                catch (e) {
                    return "The additional[" + idx + "] value could not be parsed using JSON.stringify().";
                }
            });
        };
        return NGXLoggerUtils;
    }());

    var LogPosition = /** @class */ (function () {
        function LogPosition(fileName, lineNumber, columnNumber) {
            this.fileName = fileName;
            this.lineNumber = lineNumber;
            this.columnNumber = columnNumber;
        }
        LogPosition.prototype.toString = function () {
            return this.fileName + ':' + this.lineNumber + ':' + this.columnNumber;
        };
        return LogPosition;
    }());

    var NGXMapperService = /** @class */ (function () {
        function NGXMapperService(httpBackend) {
            this.httpBackend = httpBackend;
            // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
            this.sourceMapCache = new Map();
            // cache for specific log position, key is the dist position, ie 'main.js:339:21'
            this.logPositionCache = new Map();
        }
        /*
        Static Functions
       */
        NGXMapperService.getStackLine = function (proxiedSteps) {
            var error = new Error();
            try {
                // noinspection ExceptionCaughtLocallyJS
                throw error;
            }
            catch (e) {
                try {
                    // Here are different examples of stacktrace 
                    // Firefox (last line is the user code, the 4 first are ours):
                    // getStackLine@http://localhost:4200/main.js:358:23
                    // getCallerDetails@http://localhost:4200/main.js:557:44
                    // _log@http://localhost:4200/main.js:830:28
                    // debug@http://localhost:4200/main.js:652:14
                    // handleLog@http://localhost:4200/main.js:1158:29
                    // Chrome and Edge (last line is the user code):
                    // Error
                    // at Function.getStackLine (ngx-logger.js:329)
                    // at NGXMapperService.getCallerDetails (ngx-logger.js:528)
                    // at NGXLogger._log (ngx-logger.js:801)
                    // at NGXLogger.info (ngx-logger.js:631)
                    // at AppComponent.handleLog (app.component.ts:38)
                    var defaultProxy = 4; // We make 4 functions call before getting here
                    var firstStackLine = error.stack.split('\n')[0];
                    if (!firstStackLine.includes('.js:')) {
                        // The stacktrace starts with no function call (example in Chrome or Edge)
                        defaultProxy = defaultProxy + 1;
                    }
                    return error.stack.split('\n')[(defaultProxy + (proxiedSteps || 0))];
                }
                catch (e) {
                    return null;
                }
            }
        };
        NGXMapperService.getPosition = function (stackLine) {
            // strip base path, then parse filename, line, and column
            var positionStartIndex = stackLine.lastIndexOf('\/');
            var positionEndIndex = stackLine.indexOf(')');
            if (positionEndIndex < 0) {
                positionEndIndex = undefined;
            }
            var position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
            var dataArray = position.split(':');
            if (dataArray.length === 3) {
                return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
            }
            return new LogPosition('unknown', 0, 0);
        };
        NGXMapperService.getTranspileLocation = function (stackLine) {
            // Example stackLine:
            // Firefox : getStackLine@http://localhost:4200/main.js:358:23
            // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)
            var locationStartIndex = stackLine.indexOf('(');
            if (locationStartIndex < 0) {
                locationStartIndex = stackLine.lastIndexOf('@');
                if (locationStartIndex < 0) {
                    locationStartIndex = stackLine.lastIndexOf(' ');
                }
            }
            var locationEndIndex = stackLine.indexOf(')');
            if (locationEndIndex < 0) {
                locationEndIndex = undefined;
            }
            return stackLine.substring(locationStartIndex + 1, locationEndIndex);
        };
        NGXMapperService.getMapFilePath = function (stackLine) {
            var file = NGXMapperService.getTranspileLocation(stackLine);
            var mapFullPath = file.substring(0, file.lastIndexOf(':'));
            return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
        };
        NGXMapperService.getMapping = function (sourceMap, position) {
            // => ';' indicates end of a line
            // => ',' separates mappings in a line
            // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
            var sourceFileIndex = 0, // second field
            sourceCodeLine = 0, // third field
            sourceCodeColumn = 0; // fourth field
            var lines = sourceMap.mappings.split(';');
            for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                // reset column position to 0 after each line
                var generatedCodeColumn = 0;
                // decode sections in line
                var columns = lines[lineIndex].split(',');
                for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                    var decodedSection = vlq.decode(columns[columnIndex]);
                    if (decodedSection.length >= 4) {
                        // update relative positions
                        generatedCodeColumn += decodedSection[0];
                        sourceFileIndex += decodedSection[1];
                        sourceCodeLine += decodedSection[2];
                        sourceCodeColumn += decodedSection[3];
                    }
                    // check if matching map
                    if (lineIndex === position.lineNumber) {
                        if (generatedCodeColumn === position.columnNumber) {
                            // matching column and line found
                            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                        }
                        else if (columnIndex + 1 === columns.length) {
                            // matching column not found, but line is correct
                            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                        }
                    }
                }
            }
            // failed if reached
            return new LogPosition('unknown', 0, 0);
        };
        /**
         * does the http get request to get the source map
         * @param sourceMapLocation
         * @param distPosition
         */
        NGXMapperService.prototype._getSourceMap = function (sourceMapLocation, distPosition) {
            var req = new http.HttpRequest('GET', sourceMapLocation);
            var distPositionKey = distPosition.toString();
            // if the specific log position is already in cache return it
            if (this.logPositionCache.has(distPositionKey)) {
                return this.logPositionCache.get(distPositionKey);
            }
            // otherwise check if the source map is already cached for given source map location
            if (!this.sourceMapCache.has(sourceMapLocation)) {
                // obtain the source map if not cached
                this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(operators.filter(function (e) { return e instanceof http.HttpResponse; }), operators.map(function (httpResponse) { return httpResponse.body; }), operators.retry(3), operators.shareReplay(1)));
            }
            // at this point the source map is cached, use it to get specific log position mapping
            var logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(operators.map(function (sourceMap) {
                // map generated position to source position
                return NGXMapperService.getMapping(sourceMap, distPosition);
            }), operators.catchError(function () { return rxjs.of(distPosition); }), operators.shareReplay(1));
            // store specific log position in cache for given dest position and return it
            this.logPositionCache.set(distPositionKey, logPosition$);
            return logPosition$;
        };
        /**
         * Returns the LogPosition for the current log
         * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
         * and number of the call
         * @param sourceMapsEnabled
         * @param proxiedSteps
         */
        NGXMapperService.prototype.getCallerDetails = function (sourceMapsEnabled, proxiedSteps) {
            var _this = this;
            // parse generated file mapping from stack trace
            var stackLine = NGXMapperService.getStackLine(proxiedSteps);
            // if we were not able to parse the stackLine, just return an empty Log Position
            if (!stackLine) {
                return rxjs.of(new LogPosition('', 0, 0));
            }
            return rxjs.of([
                NGXMapperService.getPosition(stackLine),
                NGXMapperService.getMapFilePath(stackLine)
            ]).pipe(operators.switchMap(function (_a) {
                var _b = __read(_a, 2), distPosition = _b[0], sourceMapLocation = _b[1];
                // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
                // then just use the position of the JS instead of the source
                if (!sourceMapsEnabled) {
                    return rxjs.of(distPosition);
                }
                // finally try to get the source map and return the position
                return _this._getSourceMap(sourceMapLocation, distPosition);
            }));
        };
        return NGXMapperService;
    }());
    NGXMapperService.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NGXMapperService.ctorParameters = function () { return [
        { type: http.HttpBackend }
    ]; };

    var Levels = [
        'TRACE',
        'DEBUG',
        'INFO',
        'LOG',
        'WARN',
        'ERROR',
        'FATAL',
        'OFF'
    ];
    var NGXLogger = /** @class */ (function () {
        function NGXLogger(mapperService, httpService, loggerConfig, platformId, datePipe) {
            this.mapperService = mapperService;
            this.httpService = httpService;
            this.platformId = platformId;
            this.datePipe = datePipe;
            this._withCredentials = false;
            this._isIE = common.isPlatformBrowser(platformId) && navigator && navigator.userAgent &&
                !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
            // each instance of the logger should have their own config engine
            this.config = new NGXLoggerConfigEngine(loggerConfig);
            this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);
        }
        Object.defineProperty(NGXLogger.prototype, "level", {
            /** Get a readonly access to the level configured for the NGXLogger */
            get: function () {
                return this.config.level;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NGXLogger.prototype, "serverLogLevel", {
            /** Get a readonly access to the serverLogLevel configured for the NGXLogger */
            get: function () {
                return this.config.serverLogLevel;
            },
            enumerable: false,
            configurable: true
        });
        NGXLogger.prototype.trace = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.TRACE, message, additional);
        };
        NGXLogger.prototype.debug = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.DEBUG, message, additional);
        };
        NGXLogger.prototype.info = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.INFO, message, additional);
        };
        NGXLogger.prototype.log = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.LOG, message, additional);
        };
        NGXLogger.prototype.warn = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.WARN, message, additional);
        };
        NGXLogger.prototype.error = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.ERROR, message, additional);
        };
        NGXLogger.prototype.fatal = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
            this._log(exports.NgxLoggerLevel.FATAL, message, additional);
        };
        NGXLogger.prototype.setCustomHttpHeaders = function (headers) {
            this._customHttpHeaders = headers;
        };
        NGXLogger.prototype.setCustomParams = function (params) {
            this._customParams = params;
        };
        NGXLogger.prototype.setWithCredentialsOptionValue = function (withCredentials) {
            this._withCredentials = withCredentials;
        };
        NGXLogger.prototype.registerMonitor = function (monitor) {
            this._loggerMonitor = monitor;
        };
        NGXLogger.prototype.updateConfig = function (config) {
            this.config.updateConfig(config);
        };
        NGXLogger.prototype.getConfigSnapshot = function () {
            return this.config.getConfig();
        };
        NGXLogger.prototype._logIE = function (level, metaString, message, additional) {
            // Coloring doesn't work in IE
            // make sure additional isn't null or undefined so that ...additional doesn't error
            additional = additional || [];
            switch (level) {
                case exports.NgxLoggerLevel.WARN:
                    console.warn.apply(console, __spread([metaString + " ", message], additional));
                    break;
                case exports.NgxLoggerLevel.ERROR:
                case exports.NgxLoggerLevel.FATAL:
                    console.error.apply(console, __spread([metaString + " ", message], additional));
                    break;
                case exports.NgxLoggerLevel.INFO:
                    console.info.apply(console, __spread([metaString + " ", message], additional));
                    break;
                default:
                    console.log.apply(console, __spread([metaString + " ", message], additional));
            }
        };
        NGXLogger.prototype._logModern = function (level, metaString, message, additional) {
            var configuredColors = this.getConfigSnapshot().colorScheme;
            var color = NGXLoggerUtils.getColor(level, configuredColors);
            // make sure additional isn't null or undefined so that ...additional doesn't error
            additional = additional || [];
            switch (level) {
                case exports.NgxLoggerLevel.WARN:
                    console.warn.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                case exports.NgxLoggerLevel.ERROR:
                case exports.NgxLoggerLevel.FATAL:
                    console.error.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                case exports.NgxLoggerLevel.INFO:
                    console.info.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of
                // the console.trace statement
                // case NgxLoggerLevel.TRACE:
                //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);
                //   break;
                case exports.NgxLoggerLevel.DEBUG:
                    console.debug.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
                    break;
                default:
                    console.log.apply(console, __spread(["%c" + metaString, "color:" + color, message], additional));
            }
        };
        NGXLogger.prototype._log = function (level, message, additional, logOnServer) {
            var _this = this;
            if (additional === void 0) { additional = []; }
            if (logOnServer === void 0) { logOnServer = true; }
            var config = this.config.getConfig();
            var isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;
            var isLogLevelEnabled = level >= config.level;
            if (!(message && (isLog2Server || isLogLevelEnabled))) {
                return;
            }
            var logLevelString = Levels[level];
            message = typeof message === 'function' ? message() : message;
            // only use validated parameters for HTTP requests
            var validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);
            var timestamp = config.timestampFormat ?
                this.datePipe.transform(new Date(), config.timestampFormat) :
                new Date().toISOString();
            this.mapperService.getCallerDetails(config.enableSourceMaps, config.proxiedSteps).subscribe(function (callerDetails) {
                var logObject = {
                    // prepareMessage is needed to match NGXLogInterface
                    // Even though I think message should be of type any (same as console.xxx signature)
                    // I'm not doing this right now as this would be a breaking change
                    message: NGXLoggerUtils.prepareMessage(message),
                    additional: validatedAdditionalParameters,
                    level: level,
                    timestamp: timestamp,
                    fileName: callerDetails.fileName,
                    lineNumber: callerDetails.lineNumber.toString()
                };
                if (_this._loggerMonitor && isLogLevelEnabled) {
                    _this._loggerMonitor.onLog(logObject);
                }
                if (isLog2Server) {
                    // make sure the stack gets sent to the server (without altering the message for console logging)
                    logObject.message = message instanceof Error ? message.stack : message;
                    logObject.message = NGXLoggerUtils.prepareMessage(logObject.message);
                    var headers = _this._customHttpHeaders || new http.HttpHeaders();
                    headers.set('Content-Type', 'application/json');
                    var options = {
                        headers: headers,
                        params: _this._customParams || new http.HttpParams(),
                        responseType: config.httpResponseType || 'json',
                        withCredentials: _this._withCredentials
                    };
                    // Allow logging on server even if client log level is off
                    _this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe(function (res) {
                        // I don't think we should do anything on success
                    }, function (error) {
                        _this._log(exports.NgxLoggerLevel.ERROR, "FAILED TO LOG ON SERVER: " + message, [error], false);
                    });
                }
                // if no message or the log level is less than the environ
                if (isLogLevelEnabled && !config.disableConsoleLogging) {
                    var metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, config.disableFileDetails ? null : callerDetails.fileName, callerDetails.lineNumber.toString());
                    return _this._logFunc(level, metaString, message, additional);
                }
            });
        };
        return NGXLogger;
    }());
    NGXLogger.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    NGXLogger.ctorParameters = function () { return [
        { type: NGXMapperService },
        { type: NGXLoggerHttpService },
        { type: LoggerConfig },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
        { type: common.DatePipe }
    ]; };

    /**
     * CustomNGXLoggerService is designed to allow users to get a new instance of a logger
     */
    var CustomNGXLoggerService = /** @class */ (function () {
        function CustomNGXLoggerService(mapperService, httpService, platformId, datePipe) {
            this.mapperService = mapperService;
            this.httpService = httpService;
            this.platformId = platformId;
            this.datePipe = datePipe;
        }
        CustomNGXLoggerService.prototype.create = function (config, httpService, logMonitor, mapperService) {
            // you can inject your own httpService or use the default,
            var logger = new NGXLogger(mapperService || this.mapperService, httpService || this.httpService, config, this.platformId, this.datePipe);
            if (logMonitor) {
                logger.registerMonitor(logMonitor);
            }
            return logger;
        };
        return CustomNGXLoggerService;
    }());
    CustomNGXLoggerService.decorators = [
        { type: core.Injectable }
    ];
    /** @nocollapse */
    CustomNGXLoggerService.ctorParameters = function () { return [
        { type: NGXMapperService },
        { type: NGXLoggerHttpService },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
        { type: common.DatePipe }
    ]; };

    var LoggerModule = /** @class */ (function () {
        function LoggerModule() {
        }
        LoggerModule.forRoot = function (config) {
            return {
                ngModule: LoggerModule,
                providers: [
                    { provide: LoggerConfig, useValue: config || {} },
                    NGXLogger,
                    NGXLoggerHttpService,
                    CustomNGXLoggerService,
                    NGXMapperService
                ]
            };
        };
        LoggerModule.forChild = function () {
            return {
                ngModule: LoggerModule,
                providers: [
                    NGXLogger,
                    NGXLoggerHttpService,
                    CustomNGXLoggerService,
                    NGXMapperService
                ]
            };
        };
        return LoggerModule;
    }());
    LoggerModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    providers: [
                        NGXLogger,
                        NGXLoggerHttpService,
                        CustomNGXLoggerService,
                        NGXMapperService,
                        common.DatePipe
                    ]
                },] }
    ];

    var NGXLoggerMonitor = /** @class */ (function () {
        function NGXLoggerMonitor() {
        }
        return NGXLoggerMonitor;
    }());

    var NGXLogInterface = /** @class */ (function () {
        function NGXLogInterface() {
        }
        return NGXLogInterface;
    }());

    /*
     * Public API Surface of ngx-logger
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CustomNGXLoggerService = CustomNGXLoggerService;
    exports.DEFAULT_COLOR_SCHEME = DEFAULT_COLOR_SCHEME;
    exports.Levels = Levels;
    exports.LoggerConfig = LoggerConfig;
    exports.LoggerModule = LoggerModule;
    exports.NGXLogInterface = NGXLogInterface;
    exports.NGXLogger = NGXLogger;
    exports.NGXLoggerHttpService = NGXLoggerHttpService;
    exports.NGXLoggerMonitor = NGXLoggerMonitor;
    exports.NGXLoggerUtils = NGXLoggerUtils;
    exports.NGXMapperService = NGXMapperService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-logger.umd.js.map
