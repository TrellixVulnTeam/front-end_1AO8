{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../src/lib/types/logger-level.enum.ts","../../../src/lib/http.service.ts","../../../src/lib/logger.config.ts","../../../src/lib/config.engine.ts","../../../src/lib/resources/color-schemes.ts","../../../src/lib/utils/logger.utils.ts","../../../src/lib/types/log-position.ts","../../../src/lib/mapper.service.ts","../../../src/lib/logger.service.ts","../../../src/lib/custom-logger.service.ts","../../../src/lib/logger.module.ts","../../../src/lib/logger-monitor.ts","../../../src/lib/types/ngx-log.interface.ts"],"names":["Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","NgxLoggerLevel","NGXLoggerHttpService","httpBackend","this","prototype","logOnServer","url","log","options","req","HttpRequest","handle","pipe","filter","HttpResponse","map","httpResponse","body","Injectable","HttpBackend","NGXLoggerConfigEngine","config","_config","defineProperty","level","serverLogLevel","updateConfig","_clone","getConfig","object","cloneConfig","LoggerConfig","keys","forEach","key","DEFAULT_COLOR_SCHEME","NGXLoggerUtils","prepareMetaString","timestamp","logLevel","fileName","lineNumber","getColor","configColorScheme","TRACE","getColorFromConfig","DEBUG","INFO","LOG","WARN","ERROR","FATAL","OFF","prepareMessage","message","Error","JSON","stringify","prepareAdditionalParameters","additional","idx","LogPosition","columnNumber","toString","NGXMapperService","sourceMapCache","Map","logPositionCache","getStackLine","proxiedSteps","defaultProxy","stack","split","includes","getPosition","stackLine","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","undefined","dataArray","substring","getTranspileLocation","locationStartIndex","locationEndIndex","getMapFilePath","file","mapFullPath","getMapping","sourceMap","position","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","vlq.decode","sources","_getSourceMap","sourceMapLocation","distPosition","distPositionKey","has","get","set","retry","shareReplay","logPosition$","catchError","of","getCallerDetails","sourceMapsEnabled","_this","switchMap","_a","_b","Levels","NGXLogger","mapperService","httpService","loggerConfig","platformId","datePipe","_withCredentials","_isIE","isPlatformBrowser","navigator","userAgent","match","_logFunc","_logIE","bind","_logModern","trace","_i","_log","debug","info","warn","fatal","setCustomHttpHeaders","headers","_customHttpHeaders","setCustomParams","params","_customParams","setWithCredentialsOptionValue","withCredentials","registerMonitor","monitor","_loggerMonitor","getConfigSnapshot","metaString","console","apply","configuredColors","colorScheme","color","isLog2Server","serverLoggingUrl","isLogLevelEnabled","logLevelString","validatedAdditionalParameters","timestampFormat","transform","Date","toISOString","enableSourceMaps","subscribe","callerDetails","logObject","onLog","HttpHeaders","HttpParams","responseType","httpResponseType","res","disableConsoleLogging","disableFileDetails","Inject","args","PLATFORM_ID","DatePipe","CustomNGXLoggerService","logMonitor","logger","LoggerModule","forRoot","ngModule","providers","provide","useValue","forChild","NgModule","imports","CommonModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","export enum NgxLoggerLevel {\r\n  TRACE = 0,\r\n  DEBUG = 1,\r\n  INFO = 2,\r\n  LOG = 3,\r\n  WARN = 4,\r\n  ERROR = 5,\r\n  FATAL = 6,\r\n  OFF = 7\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport {HttpBackend, HttpRequest, HttpResponse} from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport {filter, map} from 'rxjs/operators';\r\nimport { NGXLogInterface } from './types/ngx-log.interface';\r\n\r\n\r\n\r\n@Injectable()\r\nexport class NGXLoggerHttpService {\r\n  constructor(private readonly httpBackend: HttpBackend) { }\r\n\r\n  logOnServer(url: string, log: NGXLogInterface, options: object): Observable<any> {\r\n    // HttpBackend skips all HttpInterceptors\r\n    // They may log errors using this service causing circular calls\r\n    const req = new HttpRequest<any>('POST', url, log, options || {});\r\n    return this.httpBackend.handle(req).pipe(\r\n      filter(e => e instanceof HttpResponse),\r\n      map<HttpResponse<any>, any>((httpResponse: HttpResponse<any>) => httpResponse.body)\r\n    );\r\n  }\r\n\r\n}\r\n","import { LoggerColorScheme } from \"./types/logger-color-scheme\";\r\nimport { NgxLoggerLevel } from \"./types/logger-level.enum\";\r\n\r\nexport class LoggerConfig {\r\n  level: NgxLoggerLevel;\r\n  serverLogLevel?: NgxLoggerLevel;\r\n  serverLoggingUrl?: string;\r\n  disableConsoleLogging?: boolean;\r\n  httpResponseType?: \"arraybuffer\" | \"blob\" | \"text\" | \"json\";\r\n  enableSourceMaps?: boolean;\r\n  /** Number of calls that will be ignored when trying to get line of stacktrace */\r\n  proxiedSteps?: number;\r\n  /** Timestamp format: any format accepted by Angular DatePipe. Defaults to ISOString */\r\n  timestampFormat?: string;\r\n  colorScheme?: LoggerColorScheme;\r\n  disableFileDetails?: boolean;\r\n}\r\n","import {LoggerConfig} from './logger.config';\r\nimport { NgxLoggerLevel } from './types/logger-level.enum';\r\n\r\nexport class NGXLoggerConfigEngine {\r\n\r\n  private _config: LoggerConfig;\r\n  constructor(readonly config: LoggerConfig) {\r\n    this._config = config;\r\n  }\r\n\r\n  /** Get a readonly access to the level configured for the NGXLogger */\r\n  get level(): NgxLoggerLevel {\r\n    return this._config.level;\r\n  }\r\n\r\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n  get serverLogLevel(): NgxLoggerLevel {\r\n    return this._config.serverLogLevel;\r\n  }\r\n\r\n  updateConfig(config: LoggerConfig) {\r\n    this._config = this._clone(config);\r\n  }\r\n\r\n  getConfig() {\r\n    return this._clone(this._config);\r\n  }\r\n\r\n  // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)\r\n  // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make\r\n  // this a deep clone\r\n  private _clone(object: any) {\r\n    const cloneConfig: LoggerConfig = new LoggerConfig();\r\n\r\n    Object.keys(object).forEach((key) => {\r\n      cloneConfig[key] = object[key];\r\n    });\r\n\r\n    return cloneConfig;\r\n  }\r\n}\r\n","import {LoggerColorScheme} from '../types/logger-color-scheme';\r\n\r\nexport const DEFAULT_COLOR_SCHEME: LoggerColorScheme = [\r\n  'purple',\r\n  'teal',\r\n  'gray',\r\n  'gray',\r\n  'red',\r\n  'red',\r\n  'red'\r\n];\r\n","import {DEFAULT_COLOR_SCHEME} from '../resources/color-schemes';\r\nimport {NgxLoggerLevel} from '../types/logger-level.enum';\r\n\r\nexport class NGXLoggerUtils {\r\n\r\n  static prepareMetaString(timestamp: string, logLevel: string, fileName: string, lineNumber: string) {\r\n    const fileDetails = fileName ? ` [${fileName}:${lineNumber}]` : '';\r\n\r\n    return `${timestamp} ${logLevel}${fileDetails}`;\r\n  }\r\n\r\n  static getColor(level: NgxLoggerLevel, configColorScheme?: Array<string>): string | undefined {\r\n    switch (level) {\r\n      case NgxLoggerLevel.TRACE:\r\n        return this.getColorFromConfig(NgxLoggerLevel.TRACE, configColorScheme);\r\n      case NgxLoggerLevel.DEBUG:\r\n        return this.getColorFromConfig(NgxLoggerLevel.DEBUG, configColorScheme);\r\n      case NgxLoggerLevel.INFO:\r\n        return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);\r\n      case NgxLoggerLevel.LOG:\r\n        return this.getColorFromConfig(NgxLoggerLevel.LOG, configColorScheme);\r\n      case NgxLoggerLevel.WARN:\r\n        return this.getColorFromConfig(NgxLoggerLevel.WARN, configColorScheme);\r\n      case NgxLoggerLevel.ERROR:\r\n        return this.getColorFromConfig(NgxLoggerLevel.ERROR, configColorScheme);\r\n      case NgxLoggerLevel.FATAL:\r\n        return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);\r\n      case NgxLoggerLevel.OFF:\r\n      default:\r\n        return;\r\n    }\r\n  }\r\n\r\n  private static getColorFromConfig(level: number, configColorScheme: Array<string>): string | undefined {\r\n    if (!configColorScheme) {\r\n      return DEFAULT_COLOR_SCHEME[level];\r\n    }\r\n\r\n    return configColorScheme[level];\r\n  }\r\n\r\n  static prepareMessage(message) {\r\n    try {\r\n      if (typeof message !== 'string' && !(message instanceof Error)) {\r\n        message = JSON.stringify(message, null, 2);\r\n      }\r\n    } catch (e) {\r\n      // additional = [message, ...additional];\r\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  static prepareAdditionalParameters(additional: any[]) {\r\n    if (additional === null || additional === undefined) {\r\n      return null;\r\n    }\r\n\r\n    return additional.map((next, idx) => {\r\n      try {\r\n        // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n        if (typeof next === 'object') {\r\n          JSON.stringify(next);\r\n        }\r\n\r\n        return next;\r\n      } catch (e) {\r\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n","export class LogPosition {\r\n  constructor(\r\n    public fileName: string,\r\n    public lineNumber: number,\r\n    public columnNumber: number\r\n  ) {}\r\n  toString() {\r\n    return this.fileName + ':' + this.lineNumber + ':' + this.columnNumber;\r\n  }\r\n}\r\n","import { SourceMap } from '@angular/compiler';\r\nimport { Injectable } from '@angular/core';\r\nimport { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';\r\nimport * as vlq from 'vlq';\r\nimport { Observable, of } from 'rxjs';\r\nimport { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';\r\nimport { LogPosition } from './types/log-position';\r\n\r\n@Injectable()\r\nexport class NGXMapperService {\r\n\r\n  // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'\r\n  private sourceMapCache: Map<string, Observable<SourceMap>> = new Map();\r\n\r\n  // cache for specific log position, key is the dist position, ie 'main.js:339:21'\r\n  private logPositionCache: Map<string, Observable<LogPosition>> = new Map();\r\n\r\n  constructor(private httpBackend: HttpBackend) {\r\n  }\r\n\r\n  /*\r\n  Static Functions\r\n */\r\n  private static getStackLine(proxiedSteps: number): string {\r\n    const error = new Error();\r\n\r\n    try {\r\n      // noinspection ExceptionCaughtLocallyJS\r\n      throw error;\r\n    } catch (e) {\r\n\r\n      try {\r\n        // Here are different examples of stacktrace \r\n\r\n        // Firefox (last line is the user code, the 4 first are ours):\r\n        // getStackLine@http://localhost:4200/main.js:358:23\r\n        // getCallerDetails@http://localhost:4200/main.js:557:44\r\n        // _log@http://localhost:4200/main.js:830:28\r\n        // debug@http://localhost:4200/main.js:652:14\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n\r\n        // Chrome and Edge (last line is the user code):\r\n        // Error\r\n        // at Function.getStackLine (ngx-logger.js:329)\r\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n        // at NGXLogger._log (ngx-logger.js:801)\r\n        // at NGXLogger.info (ngx-logger.js:631)\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n\r\n        let defaultProxy = 4; // We make 4 functions call before getting here\r\n        const firstStackLine = error.stack.split('\\n')[0];\r\n        if (!firstStackLine.includes('.js:')) {\r\n          // The stacktrace starts with no function call (example in Chrome or Edge)\r\n          defaultProxy = defaultProxy + 1;\r\n        }\r\n\r\n        return error.stack.split('\\n')[(defaultProxy + (proxiedSteps || 0))];\r\n      } catch (e) {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  private static getPosition(stackLine: string): LogPosition {\r\n    // strip base path, then parse filename, line, and column\r\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n    let positionEndIndex = stackLine.indexOf(')');\r\n    if (positionEndIndex < 0) {\r\n      positionEndIndex = undefined;\r\n    }\r\n\r\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n    const dataArray = position.split(':');\r\n    if (dataArray.length === 3) {\r\n      return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);\r\n    }\r\n    return new LogPosition('unknown', 0, 0);\r\n  }\r\n\r\n  private static getTranspileLocation(stackLine: string): string {\r\n    // Example stackLine:\r\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n    let locationStartIndex = stackLine.indexOf('(');\r\n    if (locationStartIndex < 0) {\r\n      locationStartIndex = stackLine.lastIndexOf('@');\r\n      if (locationStartIndex < 0) {\r\n        locationStartIndex = stackLine.lastIndexOf(' ');\r\n      }\r\n    }\r\n\r\n    let locationEndIndex = stackLine.indexOf(')');\r\n    if (locationEndIndex < 0) {\r\n      locationEndIndex = undefined;\r\n    }\r\n\r\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n  }\r\n\r\n  private static getMapFilePath(stackLine: string): string {\r\n    const file = NGXMapperService.getTranspileLocation(stackLine);\r\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n  }\r\n\r\n  private static getMapping(sourceMap: SourceMap, position: LogPosition): LogPosition {\r\n    // => ';' indicates end of a line\r\n    // => ',' separates mappings in a line\r\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n    let sourceFileIndex = 0,   // second field\r\n      sourceCodeLine = 0,    // third field\r\n      sourceCodeColumn = 0;  // fourth field\r\n\r\n    const lines = sourceMap.mappings.split(';');\r\n\r\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n      // reset column position to 0 after each line\r\n      let generatedCodeColumn = 0;\r\n      // decode sections in line\r\n      const columns = lines[lineIndex].split(',');\r\n\r\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n        const decodedSection = vlq.decode(columns[columnIndex]);\r\n        if (decodedSection.length >= 4) {\r\n          // update relative positions\r\n          generatedCodeColumn += decodedSection[0];\r\n          sourceFileIndex += decodedSection[1];\r\n          sourceCodeLine += decodedSection[2];\r\n          sourceCodeColumn += decodedSection[3];\r\n        }\r\n\r\n        // check if matching map\r\n        if (lineIndex === position.lineNumber) {\r\n          if (generatedCodeColumn === position.columnNumber) {\r\n            // matching column and line found\r\n            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);\r\n          } else if (columnIndex + 1 === columns.length) {\r\n            // matching column not found, but line is correct\r\n            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // failed if reached\r\n    return new LogPosition('unknown', 0, 0);\r\n  }\r\n\r\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\r\n  private _getSourceMap(sourceMapLocation: string, distPosition: LogPosition): Observable<LogPosition> {\r\n    const req = new HttpRequest<SourceMap>('GET', sourceMapLocation);\r\n    const distPositionKey = distPosition.toString();\r\n\r\n    // if the specific log position is already in cache return it\r\n    if (this.logPositionCache.has(distPositionKey)) {\r\n      return this.logPositionCache.get(distPositionKey);\r\n    }\r\n\r\n    // otherwise check if the source map is already cached for given source map location\r\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n      // obtain the source map if not cached\r\n      this.sourceMapCache.set(\r\n        sourceMapLocation,\r\n        this.httpBackend.handle(req).pipe(\r\n          filter((e) => e instanceof HttpResponse),\r\n          map<HttpResponse<SourceMap>, SourceMap>(\r\n            (httpResponse: HttpResponse<SourceMap>) => httpResponse.body\r\n          ),\r\n          retry(3),\r\n          shareReplay(1)\r\n        )\r\n      );\r\n    }\r\n\r\n    // at this point the source map is cached, use it to get specific log position mapping\r\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(\r\n      map<SourceMap, LogPosition>((sourceMap) =>\r\n        // map generated position to source position\r\n        NGXMapperService.getMapping(sourceMap, distPosition)\r\n      ),\r\n      catchError(() => of(distPosition)),\r\n      shareReplay(1)\r\n    );\r\n\r\n    // store specific log position in cache for given dest position and return it\r\n    this.logPositionCache.set(distPositionKey, logPosition$);\r\n\r\n    return logPosition$;\r\n  }\r\n\r\n  /**\r\n   * Returns the LogPosition for the current log\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name\r\n   * and number of the call\r\n   * @param sourceMapsEnabled\r\n   * @param proxiedSteps\r\n   */\r\n  public getCallerDetails(sourceMapsEnabled: boolean, proxiedSteps: number): Observable<LogPosition> {\r\n    // parse generated file mapping from stack trace\r\n\r\n    const stackLine = NGXMapperService.getStackLine(proxiedSteps);\r\n\r\n    // if we were not able to parse the stackLine, just return an empty Log Position\r\n    if (!stackLine) {\r\n      return of(new LogPosition('', 0, 0));\r\n    }\r\n\r\n    return of([\r\n      NGXMapperService.getPosition(stackLine),\r\n      NGXMapperService.getMapFilePath(stackLine)\r\n    ]).pipe(\r\n      switchMap<[LogPosition, string], Observable<LogPosition>>(([distPosition, sourceMapLocation]) => {\r\n\r\n        // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,\r\n        // then just use the position of the JS instead of the source\r\n        if (!sourceMapsEnabled) {\r\n          return of(distPosition);\r\n        }\r\n\r\n        // finally try to get the source map and return the position\r\n        return this._getSourceMap(sourceMapLocation, distPosition);\r\n      })\r\n    );\r\n\r\n\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import { Inject, Injectable, PLATFORM_ID } from '@angular/core';\r\nimport { HttpErrorResponse, HttpHeaders, HttpParams } from '@angular/common/http';\r\nimport { isPlatformBrowser, DatePipe } from '@angular/common';\r\n\r\nimport { NGXLoggerHttpService } from './http.service';\r\nimport { LogPosition } from './types/log-position';\r\nimport { NgxLoggerLevel } from './types/logger-level.enum';\r\nimport { LoggerConfig } from './logger.config';\r\nimport { NGXLoggerConfigEngine } from './config.engine';\r\nimport { NGXLoggerUtils } from './utils/logger.utils';\r\nimport { NGXLoggerMonitor } from './logger-monitor';\r\nimport { NGXLogInterface } from './types/ngx-log.interface';\r\nimport { NGXMapperService } from './mapper.service';\r\n\r\nexport const Levels = [\r\n  'TRACE',\r\n  'DEBUG',\r\n  'INFO',\r\n  'LOG',\r\n  'WARN',\r\n  'ERROR',\r\n  'FATAL',\r\n  'OFF'\r\n];\r\n\r\n\r\n@Injectable()\r\nexport class NGXLogger {\r\n  private readonly _isIE: boolean;\r\n  private readonly _logFunc: Function;\r\n  private config: NGXLoggerConfigEngine;\r\n  private _customHttpHeaders: HttpHeaders;\r\n  private _customParams: HttpParams;\r\n  private _withCredentials: boolean = false;\r\n\r\n  private _loggerMonitor: NGXLoggerMonitor;\r\n\r\n  constructor(private readonly mapperService: NGXMapperService, private readonly httpService: NGXLoggerHttpService,\r\n    loggerConfig: LoggerConfig, @Inject(PLATFORM_ID) private platformId,\r\n    private readonly datePipe: DatePipe) {\r\n    this._isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n      !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n\r\n    // each instance of the logger should have their own config engine\r\n    this.config = new NGXLoggerConfigEngine(loggerConfig);\r\n\r\n    this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);\r\n\r\n  }\r\n\r\n  /** Get a readonly access to the level configured for the NGXLogger */\r\n  get level(): NgxLoggerLevel {\r\n    return this.config.level;\r\n  }\r\n\r\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n  get serverLogLevel(): NgxLoggerLevel {\r\n    return this.config.serverLogLevel;\r\n  }\r\n\r\n  public trace(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.TRACE, message, additional);\r\n  }\r\n\r\n  public debug(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n  }\r\n\r\n  public info(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.INFO, message, additional);\r\n  }\r\n\r\n  public log(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.LOG, message, additional);\r\n  }\r\n\r\n  public warn(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.WARN, message, additional);\r\n  }\r\n\r\n  public error(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.ERROR, message, additional);\r\n  }\r\n\r\n  public fatal(message, ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.FATAL, message, additional);\r\n  }\r\n\r\n  public setCustomHttpHeaders(headers: HttpHeaders) {\r\n    this._customHttpHeaders = headers;\r\n  }\r\n\r\n  public setCustomParams(params: HttpParams) {\r\n    this._customParams = params;\r\n  }\r\n\r\n  public setWithCredentialsOptionValue(withCredentials: boolean) {\r\n    this._withCredentials = withCredentials;\r\n  }\r\n\r\n  public registerMonitor(monitor: NGXLoggerMonitor) {\r\n    this._loggerMonitor = monitor;\r\n  }\r\n\r\n  public updateConfig(config: LoggerConfig) {\r\n    this.config.updateConfig(config);\r\n  }\r\n\r\n  public getConfigSnapshot(): LoggerConfig {\r\n    return this.config.getConfig();\r\n  }\r\n\r\n  private _logIE(level: NgxLoggerLevel, metaString: string, message: string, additional: any[]): void {\r\n\r\n    // Coloring doesn't work in IE\r\n    // make sure additional isn't null or undefined so that ...additional doesn't error\r\n    additional = additional || [];\r\n\r\n    switch (level) {\r\n      case NgxLoggerLevel.WARN:\r\n        console.warn(`${metaString} `, message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.ERROR:\r\n      case NgxLoggerLevel.FATAL:\r\n        console.error(`${metaString} `, message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.INFO:\r\n        console.info(`${metaString} `, message, ...additional);\r\n        break;\r\n      default:\r\n        console.log(`${metaString} `, message, ...additional);\r\n    }\r\n  }\r\n\r\n  private _logModern(level: NgxLoggerLevel, metaString: string, message: string, additional: any[]): void {\r\n    const configuredColors = this.getConfigSnapshot().colorScheme;\r\n    const color = NGXLoggerUtils.getColor(level, configuredColors);\r\n\r\n    // make sure additional isn't null or undefined so that ...additional doesn't error\r\n    additional = additional || [];\r\n\r\n    switch (level) {\r\n      case NgxLoggerLevel.WARN:\r\n        console.warn(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.ERROR:\r\n      case NgxLoggerLevel.FATAL:\r\n        console.error(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.INFO:\r\n        console.info(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n        break;\r\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n      // the console.trace statement\r\n      // case NgxLoggerLevel.TRACE:\r\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n      //   break;\r\n\r\n      case NgxLoggerLevel.DEBUG:\r\n        console.debug(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n        break;\r\n      default:\r\n        console.log(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n    }\r\n  }\r\n\r\n  private _log(level: NgxLoggerLevel, message, additional: any[] = [], logOnServer: boolean = true): void {\r\n    const config = this.config.getConfig();\r\n    const isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;\r\n    const isLogLevelEnabled = level >= config.level;\r\n\r\n    if (!(message && (isLog2Server || isLogLevelEnabled))) {\r\n      return;\r\n    }\r\n\r\n    const logLevelString = Levels[level];\r\n\r\n    message = typeof message === 'function' ? message() : message;\r\n\r\n    // only use validated parameters for HTTP requests\r\n    const validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);\r\n\r\n    const timestamp = config.timestampFormat ?\r\n      this.datePipe.transform(new Date(), config.timestampFormat) :\r\n      new Date().toISOString();\r\n\r\n    this.mapperService.getCallerDetails(config.enableSourceMaps, config.proxiedSteps).subscribe((callerDetails: LogPosition) => {\r\n      const logObject: NGXLogInterface = {\r\n        // prepareMessage is needed to match NGXLogInterface\r\n        // Even though I think message should be of type any (same as console.xxx signature)\r\n        // I'm not doing this right now as this would be a breaking change\r\n        message: NGXLoggerUtils.prepareMessage(message),\r\n        additional: validatedAdditionalParameters,\r\n        level: level,\r\n        timestamp: timestamp,\r\n        fileName: callerDetails.fileName,\r\n        lineNumber: callerDetails.lineNumber.toString()\r\n      };\r\n\r\n      if (this._loggerMonitor && isLogLevelEnabled) {\r\n        this._loggerMonitor.onLog(logObject);\r\n      }\r\n\r\n      if (isLog2Server) {\r\n        // make sure the stack gets sent to the server (without altering the message for console logging)\r\n        logObject.message = message instanceof Error ? message.stack : message;\r\n        logObject.message = NGXLoggerUtils.prepareMessage(logObject.message);\r\n\r\n        const headers = this._customHttpHeaders || new HttpHeaders();\r\n        headers.set('Content-Type', 'application/json');\r\n\r\n        const options = {\r\n          headers: headers,\r\n          params: this._customParams || new HttpParams(),\r\n          responseType: config.httpResponseType || 'json',\r\n          withCredentials: this._withCredentials\r\n        };\r\n        // Allow logging on server even if client log level is off\r\n        this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe((res: any) => {\r\n          // I don't think we should do anything on success\r\n        },\r\n          (error: HttpErrorResponse) => {\r\n            this._log(NgxLoggerLevel.ERROR, `FAILED TO LOG ON SERVER: ${message}`, [error], false);\r\n          }\r\n        );\r\n      }\r\n\r\n\r\n      // if no message or the log level is less than the environ\r\n      if (isLogLevelEnabled && !config.disableConsoleLogging) {\r\n        const metaString = NGXLoggerUtils.prepareMetaString(\r\n          timestamp,\r\n          logLevelString,\r\n          config.disableFileDetails ? null : callerDetails.fileName,\r\n          callerDetails.lineNumber.toString()\r\n        );\r\n\r\n        return this._logFunc(level, metaString, message, additional);\r\n      }\r\n    });\r\n  }\r\n}\r\n","import {Inject, Injectable, PLATFORM_ID} from '@angular/core';\r\nimport { DatePipe } from '@angular/common';\r\n\r\nimport {LoggerConfig} from './logger.config';\r\nimport {NGXLoggerHttpService} from './http.service';\r\nimport {NGXLogger} from './logger.service';\r\nimport {NGXLoggerMonitor} from './logger-monitor';\r\nimport {NGXMapperService} from './mapper.service';\r\n\r\n\r\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\r\n@Injectable()\r\nexport class CustomNGXLoggerService {\r\n\r\n  constructor(private readonly mapperService: NGXMapperService,\r\n              private readonly httpService: NGXLoggerHttpService,\r\n              @Inject(PLATFORM_ID) private readonly platformId, private readonly datePipe: DatePipe) {\r\n  }\r\n\r\n  create(config: LoggerConfig, httpService?: NGXLoggerHttpService, logMonitor?: NGXLoggerMonitor,\r\n         mapperService?: NGXMapperService): NGXLogger {\r\n    // you can inject your own httpService or use the default,\r\n    const logger = new NGXLogger(mapperService || this.mapperService,\r\n      httpService || this.httpService, config, this.platformId, this.datePipe);\r\n\r\n    if (logMonitor) {\r\n      logger.registerMonitor(logMonitor);\r\n    }\r\n\r\n    return logger;\r\n  }\r\n}\r\n\r\n\r\n","import {CommonModule, DatePipe} from '@angular/common';\r\nimport {ModuleWithProviders, NgModule} from '@angular/core';\r\n\r\nimport {NGXLogger} from './logger.service';\r\nimport {LoggerConfig} from './logger.config';\r\nimport {CustomNGXLoggerService} from './custom-logger.service';\r\nimport {NGXLoggerHttpService} from './http.service';\r\nimport {NGXMapperService} from './mapper.service';\r\n\r\n@NgModule({\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  providers: [\r\n    NGXLogger,\r\n    NGXLoggerHttpService,\r\n    CustomNGXLoggerService,\r\n    NGXMapperService,\r\n    DatePipe\r\n  ]\r\n})\r\nexport class LoggerModule {\r\n  static forRoot(config: LoggerConfig | null | undefined): ModuleWithProviders<LoggerModule> {\r\n    return {\r\n      ngModule: LoggerModule,\r\n      providers: [\r\n        {provide: LoggerConfig, useValue: config || {}},\r\n        NGXLogger,\r\n        NGXLoggerHttpService,\r\n        CustomNGXLoggerService,\r\n        NGXMapperService\r\n      ]\r\n    };\r\n  }\r\n  static forChild(): ModuleWithProviders<LoggerModule> {\r\n    return {\r\n      ngModule: LoggerModule,\r\n      providers: [\r\n        NGXLogger,\r\n        NGXLoggerHttpService,\r\n        CustomNGXLoggerService,\r\n        NGXMapperService\r\n      ]\r\n    };\r\n  }\r\n}\r\n","import {NGXLogInterface} from './types/ngx-log.interface';\r\n\r\nexport abstract class NGXLoggerMonitor {\r\n  abstract onLog(logObject: NGXLogInterface): void;\r\n}\r\n","import {NgxLoggerLevel} from './logger-level.enum';\r\n\r\nexport class NGXLogInterface {\r\n  level: NgxLoggerLevel;\r\n  timestamp: string;\r\n  fileName: string;\r\n  lineNumber: string;\r\n  message: string;\r\n  additional: any[];\r\n}\r\n"]}