import { isPlatformBrowser, DatePipe, CommonModule } from '@angular/common';
import { Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';
import { HttpRequest, HttpResponse, HttpBackend, HttpHeaders, HttpParams } from '@angular/common/http';
import { filter, map, retry, shareReplay, catchError, switchMap } from 'rxjs/operators';
import { decode } from 'vlq';
import { of } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
import * as ɵngcc2 from '@angular/common';
class NGXLoggerHttpService {
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
    }
    logOnServer(url, log, options) {
        // HttpBackend skips all HttpInterceptors
        // They may log errors using this service causing circular calls
        const req = new HttpRequest('POST', url, log, options || {});
        return this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));
    }
}
NGXLoggerHttpService.ɵfac = function NGXLoggerHttpService_Factory(t) { return new (t || NGXLoggerHttpService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpBackend)); };
NGXLoggerHttpService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NGXLoggerHttpService, factory: NGXLoggerHttpService.ɵfac });
/** @nocollapse */
NGXLoggerHttpService.ctorParameters = () => [
    { type: HttpBackend }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NGXLoggerHttpService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpBackend }]; }, null); })();

var NgxLoggerLevel;
(function (NgxLoggerLevel) {
    NgxLoggerLevel[NgxLoggerLevel["TRACE"] = 0] = "TRACE";
    NgxLoggerLevel[NgxLoggerLevel["DEBUG"] = 1] = "DEBUG";
    NgxLoggerLevel[NgxLoggerLevel["INFO"] = 2] = "INFO";
    NgxLoggerLevel[NgxLoggerLevel["LOG"] = 3] = "LOG";
    NgxLoggerLevel[NgxLoggerLevel["WARN"] = 4] = "WARN";
    NgxLoggerLevel[NgxLoggerLevel["ERROR"] = 5] = "ERROR";
    NgxLoggerLevel[NgxLoggerLevel["FATAL"] = 6] = "FATAL";
    NgxLoggerLevel[NgxLoggerLevel["OFF"] = 7] = "OFF";
})(NgxLoggerLevel || (NgxLoggerLevel = {}));

class LoggerConfig {
}

class NGXLoggerConfigEngine {
    constructor(config) {
        this.config = config;
        this._config = config;
    }
    /** Get a readonly access to the level configured for the NGXLogger */
    get level() {
        return this._config.level;
    }
    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */
    get serverLogLevel() {
        return this._config.serverLogLevel;
    }
    updateConfig(config) {
        this._config = this._clone(config);
    }
    getConfig() {
        return this._clone(this._config);
    }
    // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)
    // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make
    // this a deep clone
    _clone(object) {
        const cloneConfig = new LoggerConfig();
        Object.keys(object).forEach((key) => {
            cloneConfig[key] = object[key];
        });
        return cloneConfig;
    }
}

const DEFAULT_COLOR_SCHEME = [
    'purple',
    'teal',
    'gray',
    'gray',
    'red',
    'red',
    'red'
];

class NGXLoggerUtils {
    static prepareMetaString(timestamp, logLevel, fileName, lineNumber) {
        const fileDetails = fileName ? ` [${fileName}:${lineNumber}]` : '';
        return `${timestamp} ${logLevel}${fileDetails}`;
    }
    static getColor(level, configColorScheme) {
        switch (level) {
            case NgxLoggerLevel.TRACE:
                return this.getColorFromConfig(NgxLoggerLevel.TRACE, configColorScheme);
            case NgxLoggerLevel.DEBUG:
                return this.getColorFromConfig(NgxLoggerLevel.DEBUG, configColorScheme);
            case NgxLoggerLevel.INFO:
                return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);
            case NgxLoggerLevel.LOG:
                return this.getColorFromConfig(NgxLoggerLevel.LOG, configColorScheme);
            case NgxLoggerLevel.WARN:
                return this.getColorFromConfig(NgxLoggerLevel.WARN, configColorScheme);
            case NgxLoggerLevel.ERROR:
                return this.getColorFromConfig(NgxLoggerLevel.ERROR, configColorScheme);
            case NgxLoggerLevel.FATAL:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.OFF:
            default:
                return;
        }
    }
    static getColorFromConfig(level, configColorScheme) {
        if (!configColorScheme) {
            return DEFAULT_COLOR_SCHEME[level];
        }
        return configColorScheme[level];
    }
    static prepareMessage(message) {
        try {
            if (typeof message !== 'string' && !(message instanceof Error)) {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (e) {
            // additional = [message, ...additional];
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    }
    static prepareAdditionalParameters(additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map((next, idx) => {
            try {
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                if (typeof next === 'object') {
                    JSON.stringify(next);
                }
                return next;
            }
            catch (e) {
                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;
            }
        });
    }
}

class LogPosition {
    constructor(fileName, lineNumber, columnNumber) {
        this.fileName = fileName;
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
    toString() {
        return this.fileName + ':' + this.lineNumber + ':' + this.columnNumber;
    }
}

class NGXMapperService {
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
        // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
        this.sourceMapCache = new Map();
        // cache for specific log position, key is the dist position, ie 'main.js:339:21'
        this.logPositionCache = new Map();
    }
    /*
    Static Functions
   */
    static getStackLine(proxiedSteps) {
        const error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                // Here are different examples of stacktrace 
                // Firefox (last line is the user code, the 4 first are ours):
                // getStackLine@http://localhost:4200/main.js:358:23
                // getCallerDetails@http://localhost:4200/main.js:557:44
                // _log@http://localhost:4200/main.js:830:28
                // debug@http://localhost:4200/main.js:652:14
                // handleLog@http://localhost:4200/main.js:1158:29
                // Chrome and Edge (last line is the user code):
                // Error
                // at Function.getStackLine (ngx-logger.js:329)
                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)
                // at NGXLogger._log (ngx-logger.js:801)
                // at NGXLogger.info (ngx-logger.js:631)
                // at AppComponent.handleLog (app.component.ts:38)
                let defaultProxy = 4; // We make 4 functions call before getting here
                const firstStackLine = error.stack.split('\n')[0];
                if (!firstStackLine.includes('.js:')) {
                    // The stacktrace starts with no function call (example in Chrome or Edge)
                    defaultProxy = defaultProxy + 1;
                }
                return error.stack.split('\n')[(defaultProxy + (proxiedSteps || 0))];
            }
            catch (e) {
                return null;
            }
        }
    }
    static getPosition(stackLine) {
        // strip base path, then parse filename, line, and column
        const positionStartIndex = stackLine.lastIndexOf('\/');
        let positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        const dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    }
    static getTranspileLocation(stackLine) {
        // Example stackLine:
        // Firefox : getStackLine@http://localhost:4200/main.js:358:23
        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)
        let locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf('@');
            if (locationStartIndex < 0) {
                locationStartIndex = stackLine.lastIndexOf(' ');
            }
        }
        let locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    }
    static getMapFilePath(stackLine) {
        const file = NGXMapperService.getTranspileLocation(stackLine);
        const mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    }
    static getMapping(sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        let sourceFileIndex = 0, // second field
        sourceCodeLine = 0, // third field
        sourceCodeColumn = 0; // fourth field
        const lines = sourceMap.mappings.split(';');
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            let generatedCodeColumn = 0;
            // decode sections in line
            const columns = lines[lineIndex].split(',');
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                const decodedSection = decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * does the http get request to get the source map
     * @param sourceMapLocation
     * @param distPosition
     */
    _getSourceMap(sourceMapLocation, distPosition) {
        const req = new HttpRequest('GET', sourceMapLocation);
        const distPositionKey = distPosition.toString();
        // if the specific log position is already in cache return it
        if (this.logPositionCache.has(distPositionKey)) {
            return this.logPositionCache.get(distPositionKey);
        }
        // otherwise check if the source map is already cached for given source map location
        if (!this.sourceMapCache.has(sourceMapLocation)) {
            // obtain the source map if not cached
            this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));
        }
        // at this point the source map is cached, use it to get specific log position mapping
        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => 
        // map generated position to source position
        NGXMapperService.getMapping(sourceMap, distPosition)), catchError(() => of(distPosition)), shareReplay(1));
        // store specific log position in cache for given dest position and return it
        this.logPositionCache.set(distPositionKey, logPosition$);
        return logPosition$;
    }
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param sourceMapsEnabled
     * @param proxiedSteps
     */
    getCallerDetails(sourceMapsEnabled, proxiedSteps) {
        // parse generated file mapping from stack trace
        const stackLine = NGXMapperService.getStackLine(proxiedSteps);
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap(([distPosition, sourceMapLocation]) => {
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return this._getSourceMap(sourceMapLocation, distPosition);
        }));
    }
}
NGXMapperService.ɵfac = function NGXMapperService_Factory(t) { return new (t || NGXMapperService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpBackend)); };
NGXMapperService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NGXMapperService, factory: NGXMapperService.ɵfac });
/** @nocollapse */
NGXMapperService.ctorParameters = () => [
    { type: HttpBackend }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NGXMapperService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.HttpBackend }]; }, null); })();

const Levels = [
    'TRACE',
    'DEBUG',
    'INFO',
    'LOG',
    'WARN',
    'ERROR',
    'FATAL',
    'OFF'
];
class NGXLogger {
    constructor(mapperService, httpService, loggerConfig, platformId, datePipe) {
        this.mapperService = mapperService;
        this.httpService = httpService;
        this.platformId = platformId;
        this.datePipe = datePipe;
        this._withCredentials = false;
        this._isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&
            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\//) || navigator.userAgent.match(/Edge\//));
        // each instance of the logger should have their own config engine
        this.config = new NGXLoggerConfigEngine(loggerConfig);
        this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);
    }
    /** Get a readonly access to the level configured for the NGXLogger */
    get level() {
        return this.config.level;
    }
    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */
    get serverLogLevel() {
        return this.config.serverLogLevel;
    }
    trace(message, ...additional) {
        this._log(NgxLoggerLevel.TRACE, message, additional);
    }
    debug(message, ...additional) {
        this._log(NgxLoggerLevel.DEBUG, message, additional);
    }
    info(message, ...additional) {
        this._log(NgxLoggerLevel.INFO, message, additional);
    }
    log(message, ...additional) {
        this._log(NgxLoggerLevel.LOG, message, additional);
    }
    warn(message, ...additional) {
        this._log(NgxLoggerLevel.WARN, message, additional);
    }
    error(message, ...additional) {
        this._log(NgxLoggerLevel.ERROR, message, additional);
    }
    fatal(message, ...additional) {
        this._log(NgxLoggerLevel.FATAL, message, additional);
    }
    setCustomHttpHeaders(headers) {
        this._customHttpHeaders = headers;
    }
    setCustomParams(params) {
        this._customParams = params;
    }
    setWithCredentialsOptionValue(withCredentials) {
        this._withCredentials = withCredentials;
    }
    registerMonitor(monitor) {
        this._loggerMonitor = monitor;
    }
    updateConfig(config) {
        this.config.updateConfig(config);
    }
    getConfigSnapshot() {
        return this.config.getConfig();
    }
    _logIE(level, metaString, message, additional) {
        // Coloring doesn't work in IE
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn(`${metaString} `, message, ...additional);
                break;
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                console.error(`${metaString} `, message, ...additional);
                break;
            case NgxLoggerLevel.INFO:
                console.info(`${metaString} `, message, ...additional);
                break;
            default:
                console.log(`${metaString} `, message, ...additional);
        }
    }
    _logModern(level, metaString, message, additional) {
        const configuredColors = this.getConfigSnapshot().colorScheme;
        const color = NGXLoggerUtils.getColor(level, configuredColors);
        // make sure additional isn't null or undefined so that ...additional doesn't error
        additional = additional || [];
        switch (level) {
            case NgxLoggerLevel.WARN:
                console.warn(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            case NgxLoggerLevel.ERROR:
            case NgxLoggerLevel.FATAL:
                console.error(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            case NgxLoggerLevel.INFO:
                console.info(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of
            // the console.trace statement
            // case NgxLoggerLevel.TRACE:
            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);
            //   break;
            case NgxLoggerLevel.DEBUG:
                console.debug(`%c${metaString}`, `color:${color}`, message, ...additional);
                break;
            default:
                console.log(`%c${metaString}`, `color:${color}`, message, ...additional);
        }
    }
    _log(level, message, additional = [], logOnServer = true) {
        const config = this.config.getConfig();
        const isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;
        const isLogLevelEnabled = level >= config.level;
        if (!(message && (isLog2Server || isLogLevelEnabled))) {
            return;
        }
        const logLevelString = Levels[level];
        message = typeof message === 'function' ? message() : message;
        // only use validated parameters for HTTP requests
        const validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);
        const timestamp = config.timestampFormat ?
            this.datePipe.transform(new Date(), config.timestampFormat) :
            new Date().toISOString();
        this.mapperService.getCallerDetails(config.enableSourceMaps, config.proxiedSteps).subscribe((callerDetails) => {
            const logObject = {
                // prepareMessage is needed to match NGXLogInterface
                // Even though I think message should be of type any (same as console.xxx signature)
                // I'm not doing this right now as this would be a breaking change
                message: NGXLoggerUtils.prepareMessage(message),
                additional: validatedAdditionalParameters,
                level: level,
                timestamp: timestamp,
                fileName: callerDetails.fileName,
                lineNumber: callerDetails.lineNumber.toString()
            };
            if (this._loggerMonitor && isLogLevelEnabled) {
                this._loggerMonitor.onLog(logObject);
            }
            if (isLog2Server) {
                // make sure the stack gets sent to the server (without altering the message for console logging)
                logObject.message = message instanceof Error ? message.stack : message;
                logObject.message = NGXLoggerUtils.prepareMessage(logObject.message);
                const headers = this._customHttpHeaders || new HttpHeaders();
                headers.set('Content-Type', 'application/json');
                const options = {
                    headers: headers,
                    params: this._customParams || new HttpParams(),
                    responseType: config.httpResponseType || 'json',
                    withCredentials: this._withCredentials
                };
                // Allow logging on server even if client log level is off
                this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe((res) => {
                    // I don't think we should do anything on success
                }, (error) => {
                    this._log(NgxLoggerLevel.ERROR, `FAILED TO LOG ON SERVER: ${message}`, [error], false);
                });
            }
            // if no message or the log level is less than the environ
            if (isLogLevelEnabled && !config.disableConsoleLogging) {
                const metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString, config.disableFileDetails ? null : callerDetails.fileName, callerDetails.lineNumber.toString());
                return this._logFunc(level, metaString, message, additional);
            }
        });
    }
}
NGXLogger.ɵfac = function NGXLogger_Factory(t) { return new (t || NGXLogger)(ɵngcc0.ɵɵinject(NGXMapperService), ɵngcc0.ɵɵinject(NGXLoggerHttpService), ɵngcc0.ɵɵinject(LoggerConfig), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc2.DatePipe)); };
NGXLogger.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: NGXLogger, factory: NGXLogger.ɵfac });
/** @nocollapse */
NGXLogger.ctorParameters = () => [
    { type: NGXMapperService },
    { type: NGXLoggerHttpService },
    { type: LoggerConfig },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: DatePipe }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NGXLogger, [{
        type: Injectable
    }], function () { return [{ type: NGXMapperService }, { type: NGXLoggerHttpService }, { type: LoggerConfig }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc2.DatePipe }]; }, null); })();

/**
 * CustomNGXLoggerService is designed to allow users to get a new instance of a logger
 */
class CustomNGXLoggerService {
    constructor(mapperService, httpService, platformId, datePipe) {
        this.mapperService = mapperService;
        this.httpService = httpService;
        this.platformId = platformId;
        this.datePipe = datePipe;
    }
    create(config, httpService, logMonitor, mapperService) {
        // you can inject your own httpService or use the default,
        const logger = new NGXLogger(mapperService || this.mapperService, httpService || this.httpService, config, this.platformId, this.datePipe);
        if (logMonitor) {
            logger.registerMonitor(logMonitor);
        }
        return logger;
    }
}
CustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) { return new (t || CustomNGXLoggerService)(ɵngcc0.ɵɵinject(NGXMapperService), ɵngcc0.ɵɵinject(NGXLoggerHttpService), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc2.DatePipe)); };
CustomNGXLoggerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CustomNGXLoggerService, factory: CustomNGXLoggerService.ɵfac });
/** @nocollapse */
CustomNGXLoggerService.ctorParameters = () => [
    { type: NGXMapperService },
    { type: NGXLoggerHttpService },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: DatePipe }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CustomNGXLoggerService, [{
        type: Injectable
    }], function () { return [{ type: NGXMapperService }, { type: NGXLoggerHttpService }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc2.DatePipe }]; }, null); })();

class LoggerModule {
    static forRoot(config) {
        return {
            ngModule: LoggerModule,
            providers: [
                { provide: LoggerConfig, useValue: config || {} },
                NGXLogger,
                NGXLoggerHttpService,
                CustomNGXLoggerService,
                NGXMapperService
            ]
        };
    }
    static forChild() {
        return {
            ngModule: LoggerModule,
            providers: [
                NGXLogger,
                NGXLoggerHttpService,
                CustomNGXLoggerService,
                NGXMapperService
            ]
        };
    }
}
LoggerModule.ɵfac = function LoggerModule_Factory(t) { return new (t || LoggerModule)(); };
LoggerModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: LoggerModule });
LoggerModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        NGXLogger,
        NGXLoggerHttpService,
        CustomNGXLoggerService,
        NGXMapperService,
        DatePipe
    ], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LoggerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                providers: [
                    NGXLogger,
                    NGXLoggerHttpService,
                    CustomNGXLoggerService,
                    NGXMapperService,
                    DatePipe
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LoggerModule, { imports: function () { return [CommonModule]; } }); })();

class NGXLoggerMonitor {
}

class NGXLogInterface {
}

/*
 * Public API Surface of ngx-logger
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, Levels, LoggerConfig, LoggerModule, NGXLogInterface, NGXLogger, NGXLoggerHttpService, NGXLoggerMonitor, NGXLoggerUtils, NGXMapperService, NgxLoggerLevel };

//# sourceMappingURL=ngx-logger.js.map